name: CI Tests (Kind)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - homologation
          - production
      branch:
        description: 'Branch to deploy'
        required: true
        type: string
        default: 'develop'
  
  push:
    branches:
      - develop
      - 'feature/**'
      - 'bugfix/**'
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'

env:
  REGISTRY: localhost:5000
  IMAGE_NAME: goshortener

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      cluster_name: ${{ steps.set-env.outputs.cluster_name }}
      namespace: ${{ steps.set-env.outputs.namespace }}
      replicas: ${{ steps.set-env.outputs.replicas }}
      image_tag_prefix: ${{ steps.set-env.outputs.image_tag_prefix }}
      log_level: ${{ steps.set-env.outputs.log_level }}
      memory_request: ${{ steps.set-env.outputs.memory_request }}
      memory_limit: ${{ steps.set-env.outputs.memory_limit }}
      cpu_request: ${{ steps.set-env.outputs.cpu_request }}
      cpu_limit: ${{ steps.set-env.outputs.cpu_limit }}
      environment: ${{ steps.set-env.outputs.environment }}
      test_branch: ${{ steps.set-env.outputs.test_branch }}
    
    steps:
      - name: Determine Environment and Branch
        id: set-env
        run: |
          # Se foi push autom√°tico
          if [ "${{ github.event_name }}" == "push" ]; then
            ENV="homologation"
            BRANCH="${{ github.ref_name }}"
            echo "üîÑ Teste autom√°tico via push"
          else
            # Se foi manual
            ENV="${{ github.event.inputs.environment }}"
            BRANCH="${{ github.event.inputs.branch }}"
            echo "üë§ Teste manual"
          fi
          
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "test_branch=$BRANCH" >> $GITHUB_OUTPUT
          
          echo "üîß Configurando para: $ENV (branch: $BRANCH)"
          
          # Valida√ß√µes espec√≠ficas por ambiente
          if [ "$ENV" == "production" ]; then
            # Produ√ß√£o: branch deve ser main ou hotfix
            if [[ "$BRANCH" != "main" ]] && [[ "$BRANCH" != hotfix/* ]]; then
              echo "‚ùå Produ√ß√£o s√≥ aceita branch 'main' ou 'hotfix/*'"
              echo "Branch fornecida: $BRANCH"
              exit 1
            fi
            
            echo "cluster_name=goshortener-prd" >> $GITHUB_OUTPUT
            echo "namespace=goshortener-prd" >> $GITHUB_OUTPUT
            echo "replicas=3" >> $GITHUB_OUTPUT
            echo "image_tag_prefix=prd" >> $GITHUB_OUTPUT
            echo "log_level=info" >> $GITHUB_OUTPUT
            echo "memory_request=256Mi" >> $GITHUB_OUTPUT
            echo "memory_limit=512Mi" >> $GITHUB_OUTPUT
            echo "cpu_request=250m" >> $GITHUB_OUTPUT
            echo "cpu_limit=500m" >> $GITHUB_OUTPUT
            
            echo "‚úÖ Configura√ß√£o de PRODU√á√ÉO aplicada"
            
          else
            # Homologa√ß√£o: aceita qualquer branch
            echo "cluster_name=goshortener-hml" >> $GITHUB_OUTPUT
            echo "namespace=goshortener-hml" >> $GITHUB_OUTPUT
            echo "replicas=2" >> $GITHUB_OUTPUT
            echo "image_tag_prefix=hml" >> $GITHUB_OUTPUT
            echo "log_level=debug" >> $GITHUB_OUTPUT
            echo "memory_request=128Mi" >> $GITHUB_OUTPUT
            echo "memory_limit=256Mi" >> $GITHUB_OUTPUT
            echo "cpu_request=100m" >> $GITHUB_OUTPUT
            echo "cpu_limit=300m" >> $GITHUB_OUTPUT
            
            echo "‚úÖ Configura√ß√£o de HOMOLOGA√á√ÉO aplicada"
          fi
          
          echo ""
          echo "üìã Resumo:"
          echo "  Environment: $ENV"
          echo "  Branch: $BRANCH"
          echo "  Trigger: ${{ github.event_name }}"

  test:
    needs: setup
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.run_tests != 'false' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.test_branch }}
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ needs.setup.outputs.environment }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ needs.setup.outputs.environment }}-
            ${{ runner.os }}-go-
      
      - name: Run tests
        run: |
          echo "üß™ Executando testes para ${{ needs.setup.outputs.environment }}..."
          go mod download
          go test -v -cover -race ./...
          go test -coverprofile=coverage.out ./...
          go tool cover -html=coverage.out -o coverage.html
          
          # Gerar relat√≥rio de cobertura
          coverage=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
          echo "üìä Cobertura de testes: $coverage"
          
          # Crit√©rios diferentes por ambiente
          if [ "${{ needs.setup.outputs.environment }}" == "production" ]; then
            if [ "${coverage%.*}" -lt 80 ]; then
              echo "‚ùå Cobertura abaixo de 80% - Bloqueado em PRODU√á√ÉO!"
              exit 1
            else
              echo "‚úÖ Cobertura adequada para produ√ß√£o (>80%)"
            fi
          else
            if [ "${coverage%.*}" -lt 80 ]; then
              echo "‚ö†Ô∏è Cobertura abaixo de 80% - Teste continua em HML"
            else
              echo "‚úÖ Cobertura adequada"
            fi
          fi
      
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ needs.setup.outputs.environment }}
          path: coverage.html

  validate:
    needs: [setup, test]
    runs-on: ubuntu-latest
    if: ${{ always() && !failure() || (failure() && github.event.inputs.force_deploy == 'true' && needs.setup.outputs.environment == 'homologation') }}
    environment: ${{ needs.setup.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.test_branch }}
      
      - name: Install Kind
        run: |
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind
          kind version
      
      - name: Create Kind Cluster
        run: |
          CLUSTER_NAME="${{ needs.setup.outputs.cluster_name }}"
          
          echo "üîß Criando Kind cluster: $CLUSTER_NAME"
          
          cat <<EOF | kind create cluster --name ${CLUSTER_NAME} --config=-
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
          - role: control-plane
            extraPortMappings:
            - containerPort: 80
              hostPort: 8080
              protocol: TCP
          - role: worker
          containerdConfigPatches:
          - |-
            [plugins."io.containerd.grpc.v1.cri".registry.mirrors."localhost:5000"]
              endpoint = ["http://registry:5000"]
          EOF
          
          kubectl cluster-info --context kind-${CLUSTER_NAME}
          echo "‚úÖ Cluster criado!"
      
      - name: Setup Local Registry
        run: |
          # Criar registry local
          docker run -d --restart=always -p 5000:5000 --name registry registry:2
          
          # Conectar registry ao network do kind
          docker network connect kind registry
          
          echo "‚úÖ Registry configurado em localhost:5000"
      
      - name: Build and Push Image
        run: |
          TAG_PREFIX="${{ needs.setup.outputs.image_tag_prefix }}"
          ENV="${{ needs.setup.outputs.environment }}"
          
          echo "üê≥ Construindo imagem para $ENV..."
          
          docker build \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg VERSION=${{ needs.setup.outputs.deploy_branch }} \
            --build-arg ENVIRONMENT=$ENV \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_PREFIX}-latest \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_PREFIX}-${{ github.sha }} \
            .
          
          echo "üì§ Enviando para registry..."
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_PREFIX}-latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_PREFIX}-${{ github.sha }}
          
          echo "‚úÖ Imagem pronta: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_PREFIX}-${{ github.sha }}"
      
      - name: Test Kubernetes Deployment
        run: |
          CLUSTER_NAME="${{ needs.setup.outputs.cluster_name }}"
          NAMESPACE="${{ needs.setup.outputs.namespace }}"
          TAG_PREFIX="${{ needs.setup.outputs.image_tag_prefix }}"
          
          echo "üß™ Testando deployment no Kind tempor√°rio..."
          
          kubectl config use-context kind-${CLUSTER_NAME}
          
          # Criar namespace se n√£o existir
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy via kubectl
          kubectl set image deployment/goshortener \
            goshortener=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_PREFIX}-${{ github.sha }} \
            -n $NAMESPACE || \
          kubectl create deployment goshortener \
            --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_PREFIX}-${{ github.sha }} \
            --replicas=${{ needs.setup.outputs.replicas }} \
            -n $NAMESPACE
          
          # Expor servi√ßo
          kubectl expose deployment goshortener \
            --port=80 \
            --target-port=8080 \
            --type=ClusterIP \
            -n $NAMESPACE || echo "Service j√° existe"
          
          # Aguardar rollout
          kubectl rollout status deployment/goshortener -n $NAMESPACE --timeout=300s
          
          echo "‚úÖ Deploy conclu√≠do!"
      
      - name: Verify Test Deployment
        run: |
          NAMESPACE="${{ needs.setup.outputs.namespace }}"
          
          echo "üîç Verificando deployment de teste..."
          kubectl get pods,svc -n $NAMESPACE
          kubectl wait --for=condition=ready pod -l app=goshortener -n $NAMESPACE --timeout=120s || true
      
      - name: Test Summary
        run: |
          CLUSTER_NAME="${{ needs.setup.outputs.cluster_name }}"
          NAMESPACE="${{ needs.setup.outputs.namespace }}"
          
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë       CI TEST SUMMARY                                         ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "üåê Ambiente:       ${{ needs.setup.outputs.environment }}"
          echo "üì¶ Cluster:        $CLUSTER_NAME (tempor√°rio)"
          echo "üè∑Ô∏è  Namespace:      $NAMESPACE"
          echo "üåø Branch:         ${{ needs.setup.outputs.test_branch }}"
          echo "üîñ Commit:         ${{ github.sha }}"
          echo "üë§ Tested by:      ${{ github.actor }}"
          echo "‚è∞ Test time:      $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo ""
          echo "üìä Recursos:"
          kubectl get pods,svc,deploy -n $NAMESPACE
