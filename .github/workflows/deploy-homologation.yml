name: Deploy to Homologation (Manual)

# ğŸš¨ DEPLOY APENAS MANUAL - SEM TRIGGER AUTOMÃTICO
on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'develop'
        type: choice
        options:
        - develop
        - main
        - feature/test-branch
      environment:
        description: 'Confirm environment'
        required: true
        default: 'homologation'
        type: choice
        options:
        - homologation
      run_tests:
        description: 'Run tests before deploy'
        required: false
        default: true
        type: boolean
      replicas:
        description: 'Number of replicas'
        required: false
        default: '2'
        type: string

env:
  REGISTRY: localhost:5000
  IMAGE_NAME: goshortener
  MINIKUBE_PROFILE: hml
  NAMESPACE: goshortener-hml

jobs:
  validate-inputs:
    runs-on: self-hosted
    steps:
      - name: Validate Environment
        run: |
          if [ "${{ github.event.inputs.environment }}" != "homologation" ]; then
            echo "âŒ Ambiente invÃ¡lido! Deve ser 'homologation'"
            exit 1
          fi
          echo "âœ… ValidaÃ§Ã£o de entrada passou"

  test:
    needs: validate-inputs
    runs-on: self-hosted
    if: ${{ github.event.inputs.run_tests == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-hml-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-hml-
      
      - name: Run tests
        run: |
          echo "ğŸ§ª Executando testes para homologaÃ§Ã£o..."
          go mod download
          go test -v -cover -race ./...
          go test -coverprofile=coverage-hml.out ./...
          go tool cover -html=coverage-hml.out -o coverage-hml.html
          
          # Gerar relatÃ³rio de cobertura
          coverage=$(go tool cover -func=coverage-hml.out | grep total | awk '{print $3}')
          echo "ğŸ“Š Cobertura de testes: $coverage"
          
          if [ "${coverage%.*}" -lt 80 ]; then
            echo "âš ï¸ Cobertura abaixo de 80% - Deploy permitido em HML mas verificar"
          else
            echo "âœ… Cobertura adequada para homologaÃ§Ã£o"
          fi
      
      - name: Upload coverage report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report-hml
          path: coverage-hml.html

  build-and-deploy:
    needs: [validate-inputs]
    runs-on: self-hosted
    if: ${{ always() && !failure() }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}
      
      - name: Setup Minikube Environment
        run: |
          echo "ğŸ”§ Configurando ambiente de homologaÃ§Ã£o..."
          
          # Verificar se minikube estÃ¡ rodando
          if ! minikube status --profile=${{ env.MINIKUBE_PROFILE }} >/dev/null 2>&1; then
            echo "âŒ Minikube HML nÃ£o estÃ¡ rodando!"
            echo "Execute: ./scripts/setup-homologation-minikube.sh"
            exit 1
          fi
          
          # Configurar docker para usar registry do minikube
          eval $(minikube docker-env --profile=${{ env.MINIKUBE_PROFILE }})
          
          # Configurar kubectl context
          kubectl config use-context ${{ env.MINIKUBE_PROFILE }}
          
          echo "âœ… Ambiente HML configurado"
          echo "ğŸ”§ Context: $(kubectl config current-context)"
          echo "ğŸŒ IP: $(minikube ip --profile=${{ env.MINIKUBE_PROFILE }})"
      
      - name: Build Docker Image
        run: |
          eval $(minikube docker-env --profile=${{ env.MINIKUBE_PROFILE }})
          
          # Build da imagem para homologaÃ§Ã£o
          docker build \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg VERSION=${{ github.event.inputs.branch }} \
            --build-arg ENVIRONMENT=homologation \
            -t ${{ env.IMAGE_NAME }}:hml-latest \
            -t ${{ env.IMAGE_NAME }}:hml-${{ github.sha }} \
            -t ${{ env.IMAGE_NAME }}:hml-$(date +%Y%m%d-%H%M%S) .
          
          echo "âœ… Imagem construÃ­da para homologaÃ§Ã£o!"
          docker images | grep ${{ env.IMAGE_NAME }}
      
      - name: Create Kubernetes Manifests
        run: |
          mkdir -p k8s/homologation
          
          # Deployment para HML (recursos menores)
          cat > k8s/homologation/deployment.yaml <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: goshortener
            namespace: ${{ env.NAMESPACE }}
            labels:
              app: goshortener
              version: v1
              environment: homologation
          spec:
            replicas: ${{ github.event.inputs.replicas }}
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxSurge: 1
                maxUnavailable: 0
            selector:
              matchLabels:
                app: goshortener
            template:
              metadata:
                labels:
                  app: goshortener
                  version: v1
                  environment: homologation
                annotations:
                  prometheus.io/scrape: "true"
                  prometheus.io/port: "8080"
                  prometheus.io/path: "/metrics"
                  deployment.time: "$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
              spec:
                containers:
                - name: goshortener
                  image: ${{ env.IMAGE_NAME }}:hml-${{ github.sha }}
                  imagePullPolicy: IfNotPresent
                  ports:
                  - containerPort: 8080
                    name: http
                    protocol: TCP
                  env:
                  - name: PORT
                    value: "8080"
                  - name: ENVIRONMENT
                    value: "homologation"
                  - name: LOG_LEVEL
                    value: "debug"
                  - name: GIT_BRANCH
                    value: "${{ github.event.inputs.branch }}"
                  - name: GIT_COMMIT
                    value: "${{ github.sha }}"
                  resources:
                    requests:
                      memory: "128Mi"
                      cpu: "100m"
                    limits:
                      memory: "256Mi"
                      cpu: "300m"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8080
                    initialDelaySeconds: 15
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /ready
                      port: 8080
                    initialDelaySeconds: 5
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 2
                  volumeMounts:
                  - name: tmp
                    mountPath: /tmp
                volumes:
                - name: tmp
                  emptyDir: {}
          EOF
          
          # Service para HML
          cat > k8s/homologation/service.yaml <<EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: goshortener
            namespace: ${{ env.NAMESPACE }}
            labels:
              app: goshortener
              environment: homologation
          spec:
            selector:
              app: goshortener
            ports:
            - port: 80
              targetPort: 8080
              protocol: TCP
              name: http
            type: ClusterIP
          EOF
          
          # Ingress para HML
          cat > k8s/homologation/ingress.yaml <<EOF
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: goshortener
            namespace: ${{ env.NAMESPACE }}
            annotations:
              nginx.ingress.kubernetes.io/rewrite-target: /
              nginx.ingress.kubernetes.io/ssl-redirect: "false"
              nginx.ingress.kubernetes.io/configuration-snippet: |
                add_header X-Environment "Homologation" always;
                add_header X-Branch "${{ github.event.inputs.branch }}" always;
          spec:
            ingressClassName: nginx
            rules:
            - http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: goshortener
                      port:
                        number: 80
          EOF
      
      - name: Deploy to Homologation
        run: |
          echo "ğŸš€ Iniciando deploy para homologaÃ§Ã£o..."
          
          # Usar contexto do minikube HML
          kubectl config use-context ${{ env.MINIKUBE_PROFILE }}
          
          # Verificar se namespace existe
          kubectl get namespace ${{ env.NAMESPACE }} || kubectl create namespace ${{ env.NAMESPACE }}
          
          # Aplicar labels no namespace
          kubectl label namespace ${{ env.NAMESPACE }} environment=homologation --overwrite
          kubectl label namespace ${{ env.NAMESPACE }} tier=testing --overwrite
          
          # Deploy usando manifests
          kubectl apply -f k8s/homologation/deployment.yaml
          kubectl apply -f k8s/homologation/service.yaml
          kubectl apply -f k8s/homologation/ingress.yaml
          
          # Aguardar rollout com timeout menor para HML
          kubectl rollout status deployment/goshortener -n ${{ env.NAMESPACE }} --timeout=180s
          
          echo "âœ… Deploy para homologaÃ§Ã£o realizado!"
      
      - name: Integration Tests
        run: |
          echo "ğŸ§ª Executando testes de integraÃ§Ã£o..."
          
          # Aguardar pods estarem prontos
          kubectl wait --for=condition=ready pod -l app=goshortener -n ${{ env.NAMESPACE }} --timeout=60s
          
          # Obter URL do ingress
          INGRESS_IP=$(minikube ip --profile=${{ env.MINIKUBE_PROFILE }})
          echo "ğŸ”— Testing application at: http://$INGRESS_IP"
          
          # Teste de saÃºde com retry
          for i in {1..8}; do
            if curl -f --connect-timeout 10 http://$INGRESS_IP/health 2>/dev/null; then
              echo "âœ… Health check passou na tentativa $i!"
              break
            else
              echo "â³ Tentativa $i/8 falhou, aguardando 5s..."
              sleep 5
            fi
            
            if [ $i -eq 8 ]; then
              echo "âŒ Health check falhou - mas seguindo em HML"
              kubectl get pods -n ${{ env.NAMESPACE }}
              kubectl logs -l app=goshortener -n ${{ env.NAMESPACE }} --tail=10
            fi
          done
          
          # Mostrar status dos recursos
          echo "ğŸ“Š Status dos recursos em homologaÃ§Ã£o:"
          kubectl get pods,svc,ingress -n ${{ env.NAMESPACE }}
      
      - name: Functional Tests
        run: |
          INGRESS_IP=$(minikube ip --profile=${{ env.MINIKUBE_PROFILE }})
          
          echo "ğŸ”§ Executando testes funcionais em homologaÃ§Ã£o..."
          
          # Teste de encurtamento
          echo "ğŸ“ Teste 1: Encurtamento de URL"
          response=$(curl -s -X POST http://$INGRESS_IP/shorten \
            -H "Content-Type: application/json" \
            -d '{"url":"https://github.com/renanm99/goshortener"}' || echo "ERROR")
          
          if echo "$response" | grep -q "short_id"; then
            echo "âœ… Teste de encurtamento passou!"
            short_id=$(echo "$response" | grep -o '"short_id":"[^"]*"' | cut -d'"' -f4)
            echo "ğŸ”— Short ID gerado: $short_id"
            
            # Teste de redirecionamento
            echo "ğŸ”„ Teste 2: Redirecionamento"
            redirect_response=$(curl -s -I http://$INGRESS_IP/$short_id || echo "ERROR")
            if echo "$redirect_response" | grep -q "301\|302"; then
              echo "âœ… Teste de redirecionamento passou!"
            else
              echo "âš ï¸ Teste de redirecionamento falhou em HML (nÃ£o crÃ­tico)"
            fi
            
            # Teste de URL invÃ¡lida
            echo "âŒ Teste 3: URL InvÃ¡lida"
            invalid_response=$(curl -s -X POST http://$INGRESS_IP/shorten \
              -H "Content-Type: application/json" \
              -d '{"url":"invalid-url"}' || echo "ERROR")
            
            if echo "$invalid_response" | grep -q "error\|Error"; then
              echo "âœ… Teste de validaÃ§Ã£o passou!"
            else
              echo "âš ï¸ ValidaÃ§Ã£o pode ter problemas"
            fi
            
          else
            echo "âš ï¸ Teste de encurtamento falhou em HML"
            echo "Response: $response"
            echo "Continuando... (nÃ£o crÃ­tico em homologaÃ§Ã£o)"
          fi
      
      - name: Performance Test (Basic)
        run: |
          INGRESS_IP=$(minikube ip --profile=${{ env.MINIKUBE_PROFILE }})
          
          echo "âš¡ Teste bÃ¡sico de performance em homologaÃ§Ã£o..."
          
          total_time=0
          successful_requests=0
          
          for i in {1..5}; do
            start_time=$(date +%s%N)
            if curl -s -f http://$INGRESS_IP/health >/dev/null 2>&1; then
              end_time=$(date +%s%N)
              response_time=$(((end_time - start_time) / 1000000))
              echo "Request $i: ${response_time}ms âœ…"
              total_time=$((total_time + response_time))
              successful_requests=$((successful_requests + 1))
            else
              echo "Request $i: FAILED âŒ"
            fi
          done
          
          if [ $successful_requests -gt 0 ]; then
            avg_time=$((total_time / successful_requests))
            echo "ğŸ“Š MÃ©dia de resposta: ${avg_time}ms"
            echo "ğŸ“ˆ Requests sucessful: $successful_requests/5"
          fi
      
      - name: Environment Information
        run: |
          echo "ğŸ“‹ INFORMAÃ‡Ã•ES DO AMBIENTE DE HOMOLOGAÃ‡ÃƒO"
          echo "=========================================="
          echo "ğŸŒ Cluster: ${{ env.MINIKUBE_PROFILE }}"
          echo "ğŸ“¦ Namespace: ${{ env.NAMESPACE }}"
          echo "ğŸŒ¿ Branch: ${{ github.event.inputs.branch }}"
          echo "ğŸ”– Commit: ${{ github.sha }}"
          echo "ğŸ‘¤ Deployed by: ${{ github.actor }}"
          echo "â° Deploy time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ”— URL: http://$(minikube ip --profile=${{ env.MINIKUBE_PROFILE }})"
          echo ""
          echo "ğŸ“Š Recursos alocados:"
          kubectl describe deployment goshortener -n ${{ env.NAMESPACE }} | grep -A 5 "Limits:"
          echo ""
          echo "ğŸ¯ PrÃ³ximos passos:"
          echo "   1. Testar manualmente: http://$(minikube ip --profile=${{ env.MINIKUBE_PROFILE }})"
          echo "   2. Executar testes E2E se necessÃ¡rio"
          echo "   3. Validar com stakeholders"
          echo "   4. Se aprovado, promover para produÃ§Ã£o"
      
      - name: Cleanup Old Images
        if: always()
        run: |
          eval $(minikube docker-env --profile=${{ env.MINIKUBE_PROFILE }})
          
          # Manter apenas as 3 imagens mais recentes em HML
          docker images ${{ env.IMAGE_NAME }} --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep "hml-" | grep -v "hml-latest" | tail -n +4 | awk '{print $1}' | \
            xargs -r docker rmi || true
          
          echo "ğŸ§¹ Limpeza de imagens HML concluÃ­da"