name: Deploy to Server (SSH)

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy (only main allowed)'
        required: true
        type: choice
        options:
          - main
      confirmation:
        description: 'Type "DEPLOY-TO-PRODUCTION" to confirm'
        required: true
        type: string

env:
  REGISTRY: localhost:5000
  IMAGE_NAME: goshortener
  ENVIRONMENT: production
  CLUSTER_NAME: goshortener-prd
  NAMESPACE: goshortener-prd
  REPLICAS: 3

jobs:
  validate:
    runs-on: ubuntu-latest
    
    steps:
      - name: Validate Production Deploy
        run: |
          BRANCH="${{ github.event.inputs.branch }}"
          
          echo "üîß Validando deploy de PRODU√á√ÉO (branch: $BRANCH)"
          
          # Validar branch main
          if [ "$BRANCH" != "main" ]; then
            echo "‚ùå Este workflow s√≥ aceita branch 'main'"
            echo "Branch fornecida: $BRANCH"
            exit 1
          fi
          echo "‚úÖ Branch validada: main"
          
          # Validar confirma√ß√£o obrigat√≥ria
          if [ "${{ github.event.inputs.confirmation }}" != "DEPLOY-TO-PRODUCTION" ]; then
            echo "‚ùå Deploy em PRODU√á√ÉO requer confirma√ß√£o!"
            echo "Digite exatamente: DEPLOY-TO-PRODUCTION"
            exit 1
          fi
          echo "‚úÖ Confirma√ß√£o de produ√ß√£o validada"
          
          echo ""
          echo "‚ö†Ô∏è  DEPLOY EM PRODU√á√ÉO AUTORIZADO"
          echo "   Cluster: ${{ env.CLUSTER_NAME }}"
          echo "   Namespace: ${{ env.NAMESPACE }}"
          echo "   Replicas: ${{ env.REPLICAS }}"

  build:
    needs: validate
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker Image
        run: |
          echo "üê≥ Construindo imagem de PRODU√á√ÉO..."
          
          docker build \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg VERSION=${{ github.event.inputs.branch }} \
            --build-arg ENVIRONMENT=production \
            -t ${{ env.IMAGE_NAME }}:prd-${{ github.sha }} \
            -t ${{ env.IMAGE_NAME }}:prd-latest \
            --load \
            .
          
          echo "‚úÖ Imagem constru√≠da!"
      
      - name: Save Docker Image
        run: |
          echo "üíæ Salvando imagem para transfer√™ncia..."
          docker save ${{ env.IMAGE_NAME }}:prd-${{ github.sha }} | gzip > image.tar.gz
          
          echo "üìä Tamanho da imagem:"
          ls -lh image.tar.gz
      
      - name: Upload Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: image.tar.gz
          retention-days: 1

  test:
    needs: build
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-prd-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-prd-
            ${{ runner.os }}-go-
      
      - name: Run tests
        run: |
          echo "üß™ Executando testes para PRODU√á√ÉO..."
          go mod download
          go test -v -cover -race ./...
          
          echo "üìä Gerando relat√≥rio de cobertura..."
          go test -coverprofile=coverage.out ./...
          go tool cover -html=coverage.out -o coverage.html
          
          coverage=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
          echo "üìä Cobertura de testes: $coverage"
          
          # PRODU√á√ÉO: exigir cobertura m√≠nima de 80%
          if [ "${coverage%.*}" -lt 80 ]; then
            echo "‚ùå Cobertura abaixo de 80% - BLOQUEADO EM PRODU√á√ÉO!"
            exit 1
          else
            echo "‚úÖ Cobertura adequada para produ√ß√£o (‚â•80%)"
          fi
      
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-prd
          path: coverage.html
          retention-days: 7

  deploy:
    needs: [validate, build, test]
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}
      
      - name: Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
      
      - name: Setup Cloudflare Tunnel
        run: |
          # Install cloudflared
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          
          echo "‚úÖ Cloudflared instalado!"
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Configure SSH for Cloudflare Tunnel
          cat >> ~/.ssh/config <<EOF
          Host cf-ssh
            Hostname ${{ secrets.SSH_HOST }}
            User ${{ secrets.SSH_USER }}
            PubkeyAuthentication yes
            ProxyCommand cloudflared access ssh --hostname %h
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF
          
          chmod 600 ~/.ssh/config
          
          echo "‚úÖ SSH configurado para Cloudflare Tunnel!"
      
      - name: Transfer Docker Image
        run: |
          echo "üì§ Transferindo imagem para servidor PRODU√á√ÉO..."
          
          scp image.tar.gz cf-ssh:/tmp/goshortener-prd-image.tar.gz
          
          echo "‚úÖ Imagem transferida!"
      
      - name: Deploy to Production
        run: |
          echo "üöÄ Executando deploy em PRODU√á√ÉO..."
          echo "‚ö†Ô∏è  ATEN√á√ÉO: Deploy em ambiente de PRODU√á√ÉO!"
          
          ssh cf-ssh bash -s <<'EOF'
          
          set -e
          
          echo "üì¶ Carregando imagem Docker..."
          docker load < /tmp/goshortener-prd-image.tar.gz
          
          echo "üè∑Ô∏è  Tagueando imagem para registry local..."
          docker tag ${{ env.IMAGE_NAME }}:prd-${{ github.sha }} \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prd-${{ github.sha }}
          docker tag ${{ env.IMAGE_NAME }}:prd-${{ github.sha }} \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prd-latest
          
          echo "üì§ Enviando para registry local..."
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prd-${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prd-latest
          
          echo "‚ò∏Ô∏è  Configurando kubectl para PRODU√á√ÉO..."
          kubectl config use-context kind-${{ env.CLUSTER_NAME }}
          
          echo "üìù Criando namespace se necess√°rio..."
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          echo "üöÄ Aplicando deployment em PRODU√á√ÉO..."
          
          # Verificar se deployment existe
          if kubectl get deployment goshortener -n ${{ env.NAMESPACE }} &>/dev/null; then
            echo "‚ôªÔ∏è  Atualizando deployment existente em PRODU√á√ÉO..."
            kubectl set image deployment/goshortener \
              goshortener=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prd-${{ github.sha }} \
              -n ${{ env.NAMESPACE }}
          else
            echo "üÜï Criando novo deployment em PRODU√á√ÉO..."
            kubectl create deployment goshortener \
              --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prd-${{ github.sha }} \
              --replicas=${{ env.REPLICAS }} \
              -n ${{ env.NAMESPACE }}
            
            kubectl label deployment goshortener \
              app=goshortener version=v1 environment=production \
              -n ${{ env.NAMESPACE }}
            
            kubectl set env deployment/goshortener \
              ENVIRONMENT=production PORT=8080 \
              -n ${{ env.NAMESPACE }}
            
            kubectl set image deployment/goshortener \
              goshortener=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prd-${{ github.sha }} \
              -n ${{ env.NAMESPACE }}
            
            kubectl set resources deployment/goshortener \
              --requests=memory=128Mi,cpu=200m \
              --limits=memory=256Mi,cpu=500m \
              -n ${{ env.NAMESPACE }}
            
            kubectl patch deployment goshortener -n ${{ env.NAMESPACE }} --type=json -p='[
              {"op":"add","path":"/spec/template/spec/containers/0/livenessProbe","value":{"httpGet":{"path":"/health","port":8080},"initialDelaySeconds":10,"periodSeconds":10,"timeoutSeconds":5,"failureThreshold":3}},
              {"op":"add","path":"/spec/template/spec/containers/0/readinessProbe","value":{"httpGet":{"path":"/ready","port":8080},"initialDelaySeconds":5,"periodSeconds":5,"timeoutSeconds":3,"failureThreshold":3}},
              {"op":"replace","path":"/spec/template/spec/containers/0/imagePullPolicy","value":"Always"}
            ]'
          fi
          
          echo "üîå Configurando service..."
          kubectl expose deployment goshortener \
            --port=80 \
            --target-port=8080 \
            --type=ClusterIP \
            -n ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚è≥ Aguardando rollout em PRODU√á√ÉO..."
          echo "üîç Verificando status dos pods..."
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=goshortener
          
          # Aguardar com timeout maior
          if ! kubectl rollout status deployment/goshortener -n ${{ env.NAMESPACE }} --timeout=600s; then
            echo "‚ùå Rollout timeout! Verificando logs dos pods..."
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=goshortener -o wide
            kubectl describe pods -n ${{ env.NAMESPACE }} -l app=goshortener
            exit 1
          fi
          
          echo "‚úÖ Deploy PRODU√á√ÉO conclu√≠do!"
          
          echo "üßπ Limpando arquivo tempor√°rio..."
          rm -f /tmp/goshortener-prd-image.tar.gz
          
          EOF
      
      - name: Verify Production Deployment
        run: |
          echo "üîç Verificando deployment em PRODU√á√ÉO..."
          
          ssh cf-ssh bash -s <<'EOF'
          
          kubectl config use-context kind-${{ env.CLUSTER_NAME }}
          
          echo ""
          echo "üìä Status dos Pods PRODU√á√ÉO:"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=goshortener -o wide
          
          echo ""
          echo "üîå Status do Service:"
          kubectl get svc -n ${{ env.NAMESPACE }} goshortener
          
          echo ""
          echo "üìã Deployment Info:"
          kubectl describe deployment goshortener -n ${{ env.NAMESPACE }} | grep -A 5 "^Replicas\|^Image"
          
          EOF
      
      - name: Cleanup SSH
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
      
      - name: Production Deployment Summary
        run: |
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë       PRODUCTION DEPLOYMENT - SUCCESS                         ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "üåê Ambiente:       PRODUCTION"
          echo "üì¶ Cluster:        ${{ env.CLUSTER_NAME }}"
          echo "üè∑Ô∏è  Namespace:      ${{ env.NAMESPACE }}"
          echo "üî¢ Replicas:       ${{ env.REPLICAS }}"
          echo "üåø Branch:         ${{ github.event.inputs.branch }}"
          echo "üîñ Commit:         ${{ github.sha }}"
          echo "üë§ Deployed by:    ${{ github.actor }}"
          echo "‚è∞ Deploy time:    $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "üñ•Ô∏è  Server:         ${{ secrets.SSH_HOST }}"
          echo ""
          echo "‚úÖ Aplica√ß√£o deployada em PRODU√á√ÉO!"
          echo "‚ö†Ô∏è  Monitorar logs e m√©tricas!"
